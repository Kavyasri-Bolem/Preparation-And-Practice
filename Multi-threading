Multi Tasking
Difference between thread and process
Thread
The Main Thread
Thread Creation
Extending Thread Class to create a Thread
Deamon Thread
------------------------------------------------------------------
Daemon thread in Java is a special type of thread that runs in the background and performs tasks such as garbage collection, monitoring tasks, and other housekeeping activities. Unlike normal (or user) threads, daemon threads do not prevent the JVM from exiting when the program finishes running. When all user threads (non-daemon threads) finish their execution, the JVM terminates all daemon threads and exits.

Key Characteristics of Daemon Threads:
Background Services: Daemon threads are typically used for background supporting tasks.
Lifecycle: Daemon threads automatically terminate when all user threads have finished execution. The JVM exits even if daemon threads are still running.
Creation: A thread can be marked as a daemon thread by calling setDaemon(true) before the thread is started.
Usage: Commonly used for tasks that should not block the termination of a program, like garbage collection, monitoring, or handling requests in the background.
Example Usage:

public class DaemonThreadExample {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    System.out.println("Daemon thread running...");
                    try {
                        Thread.sleep(1000); // Sleep for 1 second
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        daemonThread.setDaemon(true); // Set the thread as a daemon thread
        daemonThread.start();

        System.out.println("Main thread finished.");
    }
}
Explanation:
Daemon Thread Creation:
A new thread daemonThread is created, which runs indefinitely, printing "Daemon thread running..." every second.
Before starting the thread, daemonThread.setDaemon(true) is called to mark it as a daemon thread.
Thread Execution:
The daemonThread starts running in the background.
The main thread prints "Main thread finished." and then terminates.
JVM Behavior:
Once the main thread finishes execution, the JVM exits, and the daemonThread is terminated even though it is in the middle of its infinite loop.
Important Notes:
Termination: If a user thread is still running, daemon threads will continue running. Daemon threads are terminated abruptly when all user threads have finished.
Not for Critical Tasks: Because daemon threads can be terminated at any time by the JVM, they should not be used for critical tasks or tasks that require completion.
Use Cases:
Garbage Collection: JVM's garbage collector runs as a daemon thread.
Background Monitoring: Threads that monitor system status or perform logging.
Asynchronous Tasks: Background tasks that should not block the main application from exiting.
Daemon threads are an essential feature for creating efficient and responsive Java applications, enabling background processing without preventing the JVM from shutting down when the application completes its primary tasks.

------------------------------------------------------------------
Implementing Runnable
-------------------------------------------------------------------
1. Creating a Thread by Implementing Runnable
In this method, you implement the Runnable interface and pass an instance of the implementing class to a Thread object.

Example:
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running.");
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
2. Using an Anonymous Class
You can also create a thread by using an anonymous class that implements the Runnable interface.

Example:
public class RunnableExample {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running.");
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
3. Using a Lambda Expression
With Java 8 and later, you can use lambda expressions to create instances of the Runnable interface, making the code more concise.

Example:
public class RunnableExample {
    public static void main(String[] args) {
        Runnable runnable = () -> System.out.println("Thread is running.");
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
4. Subclassing Thread and Implementing Runnable
Although not common, you can subclass the Thread class and implement the Runnable interface in the subclass. This approach is more complex and typically not recommended as it mixes the two approaches of creating threads.

Example:
class MyThread extends Thread implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running.");
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
5. Using Executors Framework
The Executors framework provides a higher-level API to manage and execute threads. It is part of the java.util.concurrent package and is recommended for creating and managing a pool of threads.

Example:
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RunnableExample {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        
        Runnable runnable = () -> System.out.println("Thread is running.");
        
        executorService.execute(runnable);
        executorService.execute(runnable);
        
        executorService.shutdown();
    }
}
Implementing Runnable Interface: Create a class that implements Runnable and pass an instance to a Thread object.
Anonymous Class: Use an anonymous class to implement Runnable directly.
Lambda Expression: Use lambda expressions for more concise code.
Subclassing Thread: Subclass Thread and implement Runnable (not common practice).
Executors Framework: Use the Executors framework for managing thread pools.

--------------------------------------------------------------------------
Deep Diving into the Thread Class
--------------------------------------------------------------------------
Synchronization in Java
---------------------------------------------------------------------------



---------------------------------------------------------------------------
Race Condition and Introduction to Concurrency
Synchronization Demo with Stacks (Synchronized Methods and Synchronized Blocks)
Using Objects as Locks
----------------------------------------------------------------------------
Every Object can be accessed as lock i.e any Wrapper class objects or class Objects

----------------------------------------------------------------------------
Synchronization in Static Methods
Rules of Synchronization
Race Condition
----------------------------------------------------------------------------
A race condition is a type of concurrency bug that occurs when two or more threads in a concurrent system (such as a multithreaded program) access shared resources (like variables, data structures, or hardware devices) at the same time and at least one thread modifies the shared resource. The final outcome depends on the non-deterministic order in which the threads execute, leading to unpredictable and potentially incorrect behavior.
Real Time Example: Ticket Booking
Characteristics of a Race Condition:
Concurrent Access: Multiple threads access shared resources simultaneously.
Unsynchronized Access: The access is not properly synchronized, allowing threads to interfere with each other.
Non-Deterministic Outcome: The result of the operations depends on the timing and order of thread execution, making the behavior unpredictable.
Example of a Race Condition:
Consider a simple example where two threads increment a shared counter:

java
Copy code
class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final count: " + counter.getCount());
    }
}
Explanation:
Shared Resource: The Counter object is shared between two threads.
Unsynchronized Access: The increment() method is not synchronized, leading to a race condition.
Non-Deterministic Outcome: The final value of count can be less than 2000 because both threads might read and write the value of count simultaneously, overwriting each other's increments.
Fixing Race Conditions:
To prevent race conditions, proper synchronization mechanisms need to be used to control the access to shared resources. Here are a few common ways to fix race conditions in Java:

1. Using synchronized Keyword:
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
2. Using ReentrantLock:
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Counter {
    private int count = 0;
    private final Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
3. Using Atomic Variables:
For simple operations like incrementing a counter, Java provides atomic variables that handle synchronization internally.
import java.util.concurrent.atomic.AtomicInteger;

class Counter {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}
Summary
Race Condition: Occurs when multiple threads access and modify shared resources concurrently without proper synchronization, leading to unpredictable results.
Prevention: Use synchronization mechanisms like the synchronized keyword, ReentrantLock, or atomic variables to ensure orderly access to shared resources.
Impact: Can cause incorrect behavior, crashes, or corrupted data in concurrent applications.

----------------------------------------------------------------------------
Thread Safety
The Volatile Keyword
Using the Volatile Keyword in Singleton Design Pattern
Producer Consumer Problem (Designing a Blocking Queue) (Introducing wait() and notify())
Thread States and Thread Transitions
Running and Yielding of a Thread
Sleeping and Waking Up of a Thread
Waiting and Notifying of a Thread
Thread Timed Out
Interruption of a Thread
Thread Joining
Thread Priority
Thread Scheduler
Deadlocks
Create a Deadlock in Java. (Interview Question)
